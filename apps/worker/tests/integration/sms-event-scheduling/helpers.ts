// apps/worker/tests/integration/sms-event-scheduling/helpers.ts
/**
 * Test Helpers for SMS Event Scheduling Integration Tests
 */

import { vi } from "vitest";
import type { Mock } from "vitest";

/**
 * Time manipulation utilities for testing
 */
export class TimeController {
  private originalDateNow: typeof Date.now;
  private currentTime: number;

  constructor() {
    this.originalDateNow = Date.now;
    this.currentTime = Date.now();
  }

  /**
   * Set the current time for testing
   */
  setTime(date: Date | string | number) {
    const timestamp =
      typeof date === "number" ? date : new Date(date).getTime();
    this.currentTime = timestamp;

    // Mock Date.now()
    vi.spyOn(Date, "now").mockReturnValue(this.currentTime);

    // Mock new Date()
    vi.spyOn(global, "Date").mockImplementation((...args: any[]) => {
      if (args.length === 0) {
        return new this.originalDateNow(this.currentTime) as any;
      }
      return new this.originalDateNow(...args) as any;
    }) as any;
  }

  /**
   * Advance time by specified milliseconds
   */
  advanceTime(ms: number) {
    this.currentTime += ms;
    this.setTime(this.currentTime);
  }

  /**
   * Advance time by minutes
   */
  advanceMinutes(minutes: number) {
    this.advanceTime(minutes * 60 * 1000);
  }

  /**
   * Advance time by hours
   */
  advanceHours(hours: number) {
    this.advanceTime(hours * 60 * 60 * 1000);
  }

  /**
   * Reset to real time
   */
  reset() {
    vi.restoreAllMocks();
  }
}

/**
 * Wait for async operations to complete
 */
export async function waitFor(
  condition: () => boolean | Promise<boolean>,
  options: {
    timeout?: number;
    interval?: number;
  } = {},
): Promise<void> {
  const { timeout = 5000, interval = 100 } = options;
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    const result = await condition();
    if (result) {
      return;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }

  throw new Error(`Timeout waiting for condition after ${timeout}ms`);
}

/**
 * Wait for a specific number of milliseconds
 */
export const delay = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Assert that a value is defined (TypeScript helper)
 */
export function assertDefined<T>(
  value: T | null | undefined,
  message?: string,
): asserts value is T {
  if (value === null || value === undefined) {
    throw new Error(message || "Expected value to be defined");
  }
}

/**
 * Create a matcher for partial object matching
 */
export function expectPartial<T extends object>(
  actual: T,
  expected: Partial<T>,
) {
  for (const [key, value] of Object.entries(expected)) {
    if (actual[key as keyof T] !== value) {
      throw new Error(
        `Expected ${key} to be ${JSON.stringify(value)}, but got ${JSON.stringify(actual[key as keyof T])}`,
      );
    }
  }
}

/**
 * Test data builders
 */
export const TestDataBuilder = {
  /**
   * Build event start time for tomorrow at specific hour
   */
  eventTomorrow(hour: number, minute: number = 0): Date {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(hour, minute, 0, 0);
    return tomorrow;
  },

  /**
   * Build event start time for today at specific hour
   */
  eventToday(hour: number, minute: number = 0): Date {
    const today = new Date();
    today.setHours(hour, minute, 0, 0);
    return today;
  },

  /**
   * Build phone number
   */
  phoneNumber(suffix: string = "1234"): string {
    return `+1555555${suffix}`;
  },

  /**
   * Build calendar event ID
   */
  calendarEventId(suffix?: string): string {
    return `test-event-${suffix || Date.now()}`;
  },
};

/**
 * Assertion helpers for SMS messages
 */
export const SMSAssertions = {
  /**
   * Assert message content follows SMS constraints
   */
  assertValidSMSContent(content: string) {
    if (content.length > 160) {
      throw new Error(`SMS message exceeds 160 characters: ${content.length}`);
    }

    if (content.trim().length === 0) {
      throw new Error("SMS message is empty");
    }

    // Check for common issues
    if (content.includes("undefined") || content.includes("null")) {
      throw new Error(`SMS message contains undefined/null values: ${content}`);
    }
  },

  /**
   * Assert message was generated by LLM or template
   */
  assertGeneratedBy(message: any, type: "llm" | "template") {
    if (message.generated_via !== type) {
      throw new Error(
        `Expected message generated by ${type}, got ${message.generated_via}`,
      );
    }
  },

  /**
   * Assert message contains expected event details
   */
  assertContainsEventDetails(content: string, eventTitle: string) {
    if (!content.includes(eventTitle)) {
      throw new Error(
        `SMS message does not contain event title "${eventTitle}": ${content}`,
      );
    }
  },
};

/**
 * Queue job helpers
 */
export const QueueHelpers = {
  /**
   * Wait for queue job to complete
   */
  async waitForJobCompletion(
    supabase: any,
    jobType: string,
    userId: string,
    timeoutMs: number = 10000,
  ) {
    const startTime = Date.now();

    while (Date.now() - startTime < timeoutMs) {
      const { data } = await supabase
        .from("queue_jobs")
        .select("*")
        .eq("job_type", jobType)
        .eq("user_id", userId)
        .order("created_at", { ascending: false })
        .limit(1)
        .single();

      if (data && data.status === "completed") {
        return data;
      }

      if (data && data.status === "failed") {
        throw new Error(`Job failed: ${data.error}`);
      }

      await delay(100);
    }

    throw new Error(`Job did not complete within ${timeoutMs}ms`);
  },

  /**
   * Get latest queue job
   */
  async getLatestJob(supabase: any, jobType: string, userId: string) {
    const { data } = await supabase
      .from("queue_jobs")
      .select("*")
      .eq("job_type", jobType)
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    return data;
  },
};
