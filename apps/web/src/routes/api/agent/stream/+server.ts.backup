// apps/web/src/routes/api/agent/stream/+server.ts
/**
 * Multi-Agent System Streaming API Endpoint
 *
 * This endpoint provides Server-Sent Events (SSE) streaming for the multi-agent system
 * with planner-executor coordination, database persistence, and tool execution.
 *
 * Architecture:
 * - Planner Agent (deepseek-chat, read-write) orchestrates complex queries
 * - Executor Agents (deepseek-coder, read-only) perform specific tasks
 * - Full database persistence for agents, plans, sessions, messages, executions
 *
 * Phase: Phase 3 - API Integration
 */

import type { RequestHandler } from './$types';
import { AgentPlannerService } from '$lib/services/agent-planner-service';
import { AgentExecutorService } from '$lib/services/agent-executor-service';
import { SmartLLMService } from '$lib/services/smart-llm-service';
import { ChatCompressionService } from '$lib/services/chat-compression-service';
import { SSEResponse } from '$lib/utils/sse-response';
import { ApiResponse } from '$lib/utils/api-response';
import type {
	ChatStreamRequest,
	ChatSession,
	ChatSessionInsert,
	ChatContextType,
	ChatMessage
} from '@buildos/shared-types';

// ============================================
// RATE LIMITING
// ============================================

const RATE_LIMIT = {
	MAX_REQUESTS_PER_MINUTE: 20, // Lower for agent system (more expensive)
	MAX_TOKENS_PER_MINUTE: 30000
};

// Track user request rates
const rateLimiter = new Map<
	string,
	{
		requests: number;
		tokens: number;
		resetAt: number;
	}
>();

// ============================================
// TYPES
// ============================================

interface AgentStreamRequest extends ChatStreamRequest {
	// Inherits: message, session_id, context_type, entity_id
	conversationHistory?: ChatMessage[]; // Previous messages for context (properly typed)
}

interface AgentSSEMessage {
	type:
		| 'session'
		| 'analysis'
		| 'plan_created'
		| 'step_start'
		| 'step_complete'
		| 'executor_spawned'
		| 'executor_result'
		| 'text'
		| 'tool_call'
		| 'tool_result'
		| 'done'
		| 'error';
	[key: string]: any;
}

// ============================================
// POST HANDLER
// ============================================

/**
 * POST /api/agent/stream
 * Stream a multi-agent system response with planner-executor coordination
 */
export const POST: RequestHandler = async ({ request, locals: { supabase, safeGetSession } }) => {
	// Check authentication
	const { user } = await safeGetSession();
	if (!user?.id) {
		return ApiResponse.unauthorized();
	}

	const userId = user.id;

	// Check rate limiting
	const now = Date.now();
	let userRateLimit = rateLimiter.get(userId);

	if (userRateLimit) {
		if (userRateLimit.resetAt > now) {
			if (userRateLimit.requests >= RATE_LIMIT.MAX_REQUESTS_PER_MINUTE) {
				return ApiResponse.error(
					'Too many requests. Agent system is more resource-intensive. Please wait before sending another message.',
					429,
					'RATE_LIMITED'
				);
			}
			if (userRateLimit.tokens >= RATE_LIMIT.MAX_TOKENS_PER_MINUTE) {
				return ApiResponse.error(
					'Token limit reached. Please wait a moment before continuing.',
					429,
					'RATE_LIMITED'
				);
			}
			userRateLimit.requests++;
		} else {
			// Reset rate limit window
			userRateLimit = {
				requests: 1,
				tokens: 0,
				resetAt: now + 60000 // 1 minute
			};
			rateLimiter.set(userId, userRateLimit);
		}
	} else {
		// Initialize rate limit window
		userRateLimit = {
			requests: 1,
			tokens: 0,
			resetAt: now + 60000
		};
		rateLimiter.set(userId, userRateLimit);
	}

	try {
		const body = (await request.json()) as AgentStreamRequest;
		const {
			message,
			session_id,
			context_type = 'global',
			entity_id,
			conversationHistory = []
		} = body;

		const rawContextType = context_type as ChatContextType;
		const normalizedContextType = (
			rawContextType === 'general' ? 'global' : rawContextType
		) as ChatContextType;

		if (!message?.trim()) {
			return ApiResponse.badRequest('Message is required');
		}

		// Get or create session
		let chatSession: ChatSession;
		let loadedConversationHistory: ChatMessage[] = [];

		if (session_id) {
			// Get existing session
			const { data: existingSession } = await supabase
				.from('chat_sessions')
				.select('*')
				.eq('id', session_id)
				.eq('user_id', userId)
				.single();

			if (!existingSession) {
				return ApiResponse.notFound('Session');
			}

			chatSession = existingSession;

			// Load conversation history from database for existing session
			const { data: messages, error: messagesError } = await supabase
				.from('chat_messages')
				.select('*')
				.eq('session_id', session_id)
				.order('created_at', { ascending: true });

			if (!messagesError && messages) {
				loadedConversationHistory = messages;
			}
		} else {
			// Create new agent chat session
			const sessionData: ChatSessionInsert = {
				user_id: userId,
				context_type: normalizedContextType,
				entity_id,
				status: 'active',
				message_count: 0,
				total_tokens_used: 0,
				tool_call_count: 0,
				title: 'Agent Session'
			};

			const { data: newSession, error: sessionError } = await supabase
				.from('chat_sessions')
				.insert(sessionData)
				.select()
				.single();

			if (sessionError) {
				console.error('Failed to create session:', sessionError);
				return ApiResponse.internalError(sessionError, 'Failed to create chat session');
			}

			chatSession = newSession;
		}

		// Save user message to chat_messages
		const { error: userMessageError } = await supabase.from('chat_messages').insert({
			session_id: chatSession.id,
			user_id: userId,
			role: 'user',
			content: message
		});

		if (userMessageError) {
			console.error('Failed to save user message:', userMessageError);
			// Don't fail the request, just log
		}

		// Initialize services
		const smartLLM = new SmartLLMService({ supabase });
		const executorService = new AgentExecutorService(supabase, smartLLM);

		// Initialize compression service for intelligent chat history compression
		const compressionService = new ChatCompressionService(supabase);

		// Initialize planner service with compression support
		const plannerService = new AgentPlannerService(
			supabase,
			executorService,
			smartLLM,
			compressionService
		);

		// Create SSE response
		const agentStream = SSEResponse.createChatStream();

		// Start streaming in background
		(async () => {
			let totalTokens = 0;
			let assistantResponse = ''; // Accumulate assistant's response
			let toolCalls: any[] = []; // Accumulate tool calls for this turn
			let toolResults: any[] = []; // Accumulate tool results (in same order as tool calls)

			try {
				// Send session hydration event
				await agentStream.sendMessage({
					type: 'session',
					session: chatSession
				});

				// Use database history if available (source of truth), otherwise use frontend history
				const historyToUse =
					loadedConversationHistory.length > 0
						? loadedConversationHistory
						: conversationHistory;

				// Process through planner (this is the entry point to the multi-agent system)
				for await (const event of plannerService.processUserMessage({
					sessionId: chatSession.id,
					userId,
					message,
					contextType: normalizedContextType,
					entityId: entity_id,
					conversationHistory: historyToUse
				})) {
					// Accumulate text for saving to database
					if (event.type === 'text' && event.content) {
						assistantResponse += event.content;
					}

					// Accumulate tool calls for saving to database
					if (event.type === 'tool_call' && event.toolCall) {
						toolCalls.push(event.toolCall);
					}

					// Accumulate tool results for saving to database
					if (event.type === 'tool_result' && event.result) {
						toolResults.push(event.result);
					}

					// Map planner events to SSE messages
					const sseMessage: AgentSSEMessage = mapPlannerEventToSSE(event);

					// Send event to client
					await agentStream.sendMessage(sseMessage);

					// Track token usage
					if (event.type === 'done' && event.plan?.tokensUsed) {
						totalTokens += event.plan.tokensUsed;
					}
				}

				// Save assistant response to database (with tool calls if any)
				// Important: Save even if no text content, as long as there are tool calls
				if (assistantResponse.trim() || toolCalls.length > 0) {
					const assistantMessageData: any = {
						session_id: chatSession.id,
						user_id: userId,
						role: 'assistant',
						content: assistantResponse || '' // Can be empty if only tool calls
					};

					// Include tool calls if any (OpenAI format)
					if (toolCalls.length > 0) {
						assistantMessageData.tool_calls = toolCalls;
					}

					const { error: assistantError } = await supabase
						.from('chat_messages')
						.insert(assistantMessageData);

					if (assistantError) {
						console.error('Failed to save assistant message:', assistantError);
					}

					// Save tool result messages (one per tool call)
					// These are separate messages with role='tool' linked to their tool_call_id
					for (let i = 0; i < toolCalls.length; i++) {
						const toolCall = toolCalls[i];
						// Match result by tool_call_id instead of array index for safety
					const result = toolResults.find((r) => r.tool_call_id === toolCall.id);

						if (result) {
							const { error: toolError } = await supabase
								.from('chat_messages')
								.insert({
									session_id: chatSession.id,
									user_id: userId,
									role: 'tool',
									content: JSON.stringify(result),
									tool_call_id: toolCall.id,
									tool_name: toolCall.function?.name || 'unknown',
									tool_result: result
								});

							if (toolError) {
								console.error('Failed to save tool result message:', toolError);
							}
						}
					}
				}

				// Update rate limiter with token usage
				const currentRate = rateLimiter.get(userId);
				if (currentRate) {
					currentRate.tokens = Math.min(
						currentRate.tokens + totalTokens,
						RATE_LIMIT.MAX_TOKENS_PER_MINUTE
					);
				}

				// Send completion message
				await agentStream.sendMessage({
					type: 'done',
					usage: {
						prompt_tokens: 0,
						completion_tokens: 0,
						total_tokens: totalTokens
					},
					finished_reason: 'stop'
				});
			} catch (streamError) {
				console.error('Agent streaming error:', streamError);

				await agentStream.sendMessage({
					type: 'error',
					error:
						streamError instanceof Error
							? streamError.message
							: 'Failed to generate response'
				});
			} finally {
				await agentStream.close();
			}
		})();

		// Return SSE response
		return agentStream.response;
	} catch (err) {
		console.error('Agent API error:', err);
		return ApiResponse.internalError(err, 'Internal server error');
	}
};

// ============================================
// GET HANDLER
// ============================================

/**
 * GET /api/agent/stream
 * Get agent chat sessions
 */
export const GET: RequestHandler = async ({ url, locals: { supabase, safeGetSession } }) => {
	// Check authentication
	const { user } = await safeGetSession();
	if (!user?.id) {
		return ApiResponse.unauthorized();
	}

	const userId = user.id;
	const sessionId = url.searchParams.get('session_id');

	if (!sessionId) {
		// Get user's active agent sessions
		const { data: sessions, error: sessionsError } = await supabase
			.from('chat_sessions')
			.select('*')
			.eq('user_id', userId)
			.eq('status', 'active')
			.order('updated_at', { ascending: false })
			.limit(10);

		if (sessionsError) {
			console.error('Failed to get sessions:', sessionsError);
			return ApiResponse.internalError(sessionsError, 'Failed to get agent sessions');
		}

		return ApiResponse.success({ sessions });
	}

	// Get specific session with messages
	const { data: chatSession, error: sessionError } = await supabase
		.from('chat_sessions')
		.select(
			`
      *,
      messages:chat_messages(*)
    `
		)
		.eq('id', sessionId)
		.eq('user_id', userId)
		.single();

	if (sessionError || !chatSession) {
		return ApiResponse.notFound('Session');
	}

	return ApiResponse.success({ session: chatSession });
};

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Map planner event types to SSE message format
 */
function mapPlannerEventToSSE(event: any): AgentSSEMessage {
	switch (event.type) {
		case 'analysis':
			return {
				type: 'analysis',
				analysis: event.analysis
			};

		case 'plan_created':
			return {
				type: 'plan_created',
				plan: event.plan
			};

		case 'step_start':
			return {
				type: 'step_start',
				step: event.step
			};

		case 'step_complete':
			return {
				type: 'step_complete',
				step: event.step
			};

		case 'executor_spawned':
			return {
				type: 'executor_spawned',
				executorId: event.executorId,
				task: event.task
			};

		case 'executor_result':
			return {
				type: 'executor_result',
				executorId: event.executorId,
				result: event.result
			};

		case 'text':
			return {
				type: 'text',
				content: event.content
			};

		case 'tool_call':
			return {
				type: 'tool_call',
				tool_call: event.toolCall
			};

		case 'tool_result':
			return {
				type: 'tool_result',
				tool_result: event.result
			};

		case 'done':
			return {
				type: 'done',
				plan: event.plan
			};

		case 'error':
			return {
				type: 'error',
				error: event.error
			};

		default:
			// Unknown event type, pass through
			return event;
	}
}
