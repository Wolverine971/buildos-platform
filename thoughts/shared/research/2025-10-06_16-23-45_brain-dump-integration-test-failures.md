---
title: Brain Dump Integration Test Failures Analysis
date: 2025-10-06
author: Claude Code
status: complete
tags: [testing, brain-dump, mocking, architecture]
related_files:
  - /Users/annawayne/buildos-platform/apps/web/src/lib/utils/__tests__/brain-dump-integration-simple.test.ts
  - /Users/annawayne/buildos-platform/apps/web/src/lib/utils/__tests__/brain-dump-processor.test.ts
  - /Users/annawayne/buildos-platform/apps/web/src/lib/utils/braindump-processor.ts
---

# Brain Dump Integration Test Failures Analysis

## Problem Summary

All 5 integration tests in `brain-dump-integration-simple.test.ts` are failing with:

```
TypeError: Cannot convert undefined or null to object
❯ vi.spyOn(processor['llmPool'], 'makeRequest').mockResolvedValue({
```

## Root Cause Analysis

### 1. **Primary Issue: Outdated Property Name**

The tests are trying to mock `processor['llmPool']` but this property **no longer exists**.

**Architecture Change:**

- **OLD**: `LLMPool` with `makeRequest()` method
- **NEW**: `SmartLLMService` with `getJSONResponse()` method

**Current Implementation** (braindump-processor.ts:53-71):

```typescript
private llmService: SmartLLMService;

constructor(supabase: SupabaseClient<Database>) {
    this.llmService = new SmartLLMService({
        httpReferer: 'https://buildos.dev',
        appName: 'BuildOS',
        supabase
    });
}
```

### 2. **Why "Cannot convert undefined or null to object"**

When the test tries `vi.spyOn(processor['llmPool'], 'makeRequest')`:

1. `processor['llmPool']` returns `undefined` (property doesn't exist)
2. `vi.spyOn()` tries to access properties on `undefined`
3. JavaScript throws: "Cannot convert undefined or null to object"

### 3. **Method Signature Difference**

**OLD (LLMPool)**:

```typescript
makeRequest(...): Promise<{
    result: any,
    content: string,
    model: string,
    usage: { total_tokens: number }
}>
```

**NEW (SmartLLMService)**:

```typescript
getJSONResponse({
    systemPrompt: string,
    userPrompt: string,
    userId: string,
    profile: 'fast' | 'balanced' | 'smart',
    operationType: string,
    projectId?: string,
    brainDumpId?: string
}): Promise<any>  // Returns JSON directly, no wrapper
```

## Dependencies That Need Mocking

The `BrainDumpProcessor` constructor creates these services that need mocking:

### Core Services (lines 52-61)

```typescript
private supabase: SupabaseClient<Database>;
private llmService: SmartLLMService;              // ← Mock this
private activityLogger: ActivityLogger;            // ← Mock this
private errorLogger: ErrorLoggerService;           // ← Mock this
private promptTemplateService: PromptTemplateService;
private operationsExecutor: OperationsExecutor;    // ← Mock this
private operationValidator: OperationValidator;
private taskTimeSlotFinder: TaskTimeSlotFinder;
private statusService: BrainDumpStatusService;
private projectDataFetcher: ProjectDataFetcher;    // ← Mock this
```

### Services That Make External Calls

1. **SmartLLMService** - Makes OpenAI API calls
2. **ActivityLogger** - Writes to `user_activity_logs` table
3. **ErrorLoggerService** - Writes to error logging tables
4. **OperationsExecutor** - Executes database operations
5. **ProjectDataFetcher** - Fetches project data from database

## What These Tests Are Actually Testing

Looking at the test file, these are **integration tests** that aim to verify:

### Test Goals

1. **End-to-end brain dump processing** - Full flow from input to operations
2. **LLM response handling** - How the processor handles AI responses
3. **Reference resolution** - How tasks reference projects (via `project_ref`)
4. **Error handling** - Graceful degradation when LLM/DB fails
5. **Database operation execution** - Creating projects and tasks

### Test Type Classification

**Current State**: Hybrid integration tests

- Mock LLM service (avoid real API costs)
- Mock database operations (for speed/isolation)
- Test real processor logic and orchestration

**NOT pure unit tests** because they test:

- Multiple components working together
- Complex orchestration logic
- Reference resolution across operations

**NOT pure integration tests** because they mock:

- External API calls (LLM)
- Database operations

## Correct Mock Setup Pattern

### Working Example (from brain-dump-processor.test.ts)

```typescript
describe("BrainDumpProcessor", () => {
  let processor: BrainDumpProcessor;
  let mockSmartLLMService: MockSmartLLMService;
  let mockActivityLogger: MockActivityLogger;
  let mockOperationsExecutor: MockOperationsExecutor;
  let mockSupabase: ReturnType<typeof createMockSupabase>;

  beforeEach(() => {
    // 1. Setup mock Supabase client
    mockSupabase = createMockSupabase();

    // 2. Create processor instance with mock Supabase
    processor = new BrainDumpProcessor(mockSupabase);

    // 3. Replace instance properties with mocks (NOT module mocks)
    mockSmartLLMService = {
      getJSONResponse: vi.fn(), // ← getJSONResponse, NOT makeRequest
    };
    (processor as any).llmService = mockSmartLLMService;

    // 4. Mock other services
    mockActivityLogger = {
      logActivity: vi.fn().mockResolvedValue(undefined),
    };
    (processor as any).activityLogger = mockActivityLogger;

    mockOperationsExecutor = {
      executeOperations: vi.fn(),
    };
    (processor as any).operationsExecutor = mockOperationsExecutor;
  });
});
```

### Key Points

1. **Create processor first** - Let it initialize all services
2. **Replace instance properties** - Don't use `vi.mock()` for these
3. **Mock `getJSONResponse`** - Not `makeRequest`
4. **Return direct JSON** - Not wrapped in `{ result, content, model, usage }`

### SmartLLMService Mock Response Format

**WRONG** (old LLMPool format):

```typescript
mockSmartLLMService.getJSONResponse.mockResolvedValue({
    result: { title: '...', operations: [...] },
    content: JSON.stringify(...),
    model: 'gpt-4o',
    usage: { total_tokens: 500 }
});
```

**CORRECT** (SmartLLMService format):

```typescript
mockSmartLLMService.getJSONResponse.mockResolvedValue({
  title: "Mobile App Development",
  summary: "React Native mobile app project",
  insights: "User wants to build a mobile application",
  operations: [
    {
      table: "projects",
      operation: "create",
      data: { name: "...", description: "..." },
    },
  ],
});
```

## Integration Test Setup Template

### Complete Setup Pattern

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { BrainDumpProcessor } from "../braindump-processor";

// Type definitions for mocks
type MockSmartLLMService = {
  getJSONResponse: ReturnType<typeof vi.fn>;
};

type MockActivityLogger = {
  logActivity: ReturnType<typeof vi.fn>;
};

type MockOperationsExecutor = {
  executeOperations: ReturnType<typeof vi.fn>;
};

type MockProjectDataFetcher = {
  getFullProjectData: ReturnType<typeof vi.fn>;
};

// Mock Supabase with chaining support
const createMockSupabase = () => {
  const mockChain = {
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    in: vi.fn().mockReturnThis(),
    single: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    limit: vi.fn().mockReturnThis(),
    rpc: vi.fn().mockResolvedValue({ data: null, error: null }),
  };

  // All methods return mockChain for chaining
  Object.keys(mockChain).forEach((key) => {
    if (!["single", "rpc"].includes(key)) {
      mockChain[key].mockReturnValue(mockChain);
    }
  });

  return mockChain;
};

describe("Brain Dump Integration Tests", () => {
  let processor: BrainDumpProcessor;
  let mockSupabase: any;
  let mockLLMService: MockSmartLLMService;
  let mockActivityLogger: MockActivityLogger;
  let mockOperationsExecutor: MockOperationsExecutor;
  let mockProjectDataFetcher: MockProjectDataFetcher;

  const testUserId = "550e8400-e29b-41d4-a716-446655440000";

  beforeEach(() => {
    // 1. Create mock Supabase
    mockSupabase = createMockSupabase();

    // 2. Create processor
    processor = new BrainDumpProcessor(mockSupabase);

    // 3. Replace llmService
    mockLLMService = {
      getJSONResponse: vi.fn(),
    };
    (processor as any).llmService = mockLLMService;

    // 4. Replace activityLogger
    mockActivityLogger = {
      logActivity: vi.fn().mockResolvedValue(undefined),
    };
    (processor as any).activityLogger = mockActivityLogger;

    // 5. Replace operationsExecutor
    mockOperationsExecutor = {
      executeOperations: vi.fn(),
    };
    (processor as any).operationsExecutor = mockOperationsExecutor;

    // 6. Replace projectDataFetcher
    mockProjectDataFetcher = {
      getFullProjectData: vi.fn().mockResolvedValue({
        user_id: testUserId,
        fullProjectWithRelations: null,
        timestamp: new Date().toISOString(),
      }),
    };
    (processor as any).projectDataFetcher = mockProjectDataFetcher;

    // Clear all mocks
    vi.clearAllMocks();
  });

  it("should process new project brain dump", async () => {
    // Mock dual processing responses
    const mockContextResponse = {
      title: "New Project",
      summary: "Project summary",
      insights: "Project insights",
      operations: [
        {
          table: "projects",
          operation: "create",
          data: {
            name: "New Project",
            description: "Project description",
            status: "active",
          },
          ref: "new-project-1",
        },
      ],
    };

    const mockTasksResponse = {
      title: "Tasks",
      summary: "Task summary",
      insights: "",
      operations: [
        {
          table: "tasks",
          operation: "create",
          data: {
            title: "First task",
            project_ref: "new-project-1",
            status: "pending",
          },
        },
      ],
    };

    // Setup mocks for dual processing (context + tasks in parallel)
    mockLLMService.getJSONResponse
      .mockResolvedValueOnce(mockContextResponse)
      .mockResolvedValueOnce(mockTasksResponse);

    // Execute
    const result = await processor.processBrainDump({
      brainDump: "Create a new project with a task",
      userId: testUserId,
      selectedProjectId: undefined,
      options: { autoExecute: false },
      brainDumpId: "test-brain-dump-1",
    });

    // Assertions
    expect(result.operations).toHaveLength(2);
    expect(result.operations[0].table).toBe("projects");
    expect(result.operations[1].table).toBe("tasks");
  });
});
```

## Dual Processing Call Pattern

### For New Projects (No selectedProjectId)

```typescript
// Dual processing makes 2 parallel calls:
mockLLMService.getJSONResponse
  .mockResolvedValueOnce(contextResponse) // Context extraction
  .mockResolvedValueOnce(tasksResponse); // Task extraction
```

### For Existing Projects (With selectedProjectId)

```typescript
// Dual processing makes 3 calls:
mockLLMService.getJSONResponse
  .mockResolvedValueOnce(prepAnalysisResponse) // Preparatory analysis
  .mockResolvedValueOnce(contextResponse) // Context extraction
  .mockResolvedValueOnce(tasksResponse); // Task extraction

// Note: Prep analysis may skip context/tasks based on recommendation
```

## Key Differences from Unit Tests

### Unit Test Approach

- Focus on single methods
- Mock all dependencies
- Test isolated behavior

### Integration Test Approach (These Tests)

- Test end-to-end flows
- Mock external services (LLM, DB)
- Test real orchestration logic
- Verify operation generation
- Check reference resolution
- Validate error handling

## Required Fixes

### 1. Replace Property Names

```diff
- vi.spyOn(processor['llmPool'], 'makeRequest')
+ mockLLMService = { getJSONResponse: vi.fn() };
+ (processor as any).llmService = mockLLMService;
```

### 2. Update Response Format

```diff
- mockResolvedValue({
-     result: mockLLMResponse,
-     content: JSON.stringify(mockLLMResponse),
-     model: 'gpt-4o',
-     usage: { total_tokens: 500 }
- })
+ mockResolvedValue({
+     title: 'Project Title',
+     summary: 'Summary',
+     insights: 'Insights',
+     operations: [...]
+ })
```

### 3. Mock Additional Services

```typescript
// Mock ActivityLogger
mockActivityLogger = {
  logActivity: vi.fn().mockResolvedValue(undefined),
};
(processor as any).activityLogger = mockActivityLogger;

// Mock ProjectDataFetcher
mockProjectDataFetcher = {
  getFullProjectData: vi.fn().mockResolvedValue({
    user_id: testUserId,
    fullProjectWithRelations: null,
    timestamp: new Date().toISOString(),
  }),
};
(processor as any).projectDataFetcher = mockProjectDataFetcher;
```

## Summary

### Why Tests Fail

1. **Wrong property name**: `llmPool` → should be `llmService`
2. **Wrong method name**: `makeRequest()` → should be `getJSONResponse()`
3. **Wrong response format**: Wrapped object → Direct JSON
4. **Missing mocks**: Other services need mocking too

### What Tests Validate

- End-to-end brain dump processing flow
- LLM response handling and parsing
- Operation generation and reference resolution
- Error handling and graceful degradation
- Database operation preparation (not execution)

### Correct Mock Pattern

1. Create processor first
2. Replace instance properties (not module mocks)
3. Mock `llmService.getJSONResponse()`
4. Return direct JSON (not wrapped)
5. Mock supporting services (ActivityLogger, OperationsExecutor, etc.)

### Next Steps

1. Update all tests to use `llmService` instead of `llmPool`
2. Change mocks to use `getJSONResponse()` instead of `makeRequest()`
3. Update response format to return direct JSON
4. Add mocks for ProjectDataFetcher and other services as needed
5. Adjust dual processing mock calls (2 for new, 3 for existing projects)
